{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Eve.Internal.Async
  ( dispatchActionAsync,
    asyncActionProvider,
    syncActionProvider,
  )
where

import Control.Concurrent
import Control.Lens
import Control.Monad
import Control.Monad.State
import Data.Typeable
import Eve.Internal.Actions
import Eve.Internal.AppState
import Eve.Internal.States

-- | Dispatch an action which is generated by some IO. Note that state of the application may have changed
-- between calling 'dispatchActionAsync' and running the resulting 'Action'
dispatchActionAsync ::
  (MonadIO m, HasStates base, Typeable m, Typeable base) => IO (AppT base m ()) -> ActionT base zoomed m ()
dispatchActionAsync asyncAction = runApp $ do
  mQueue <- use asyncQueue
  case mQueue of
    Nothing -> return ()
    Just queue -> liftIO . void . forkIO $ asyncAction >>= writeChan queue

-- | This allows long-running IO processes to provide 'Action's to the application asyncronously.
--
-- 'asyncEventProvider' is simpler to use, however 'asyncActionProvider' provides
-- more power and expressivity. When in doubt, 'asyncEventProvider' probably meets
-- your needs.
--
-- Don't let the type signature confuse you; it's much simpler than it seems.
--
-- Let's break it down:
--
-- When you call 'asyncActionProvider' you pass it a function which accepts a @dispatch@ function as an argument
-- and then calls it with various 'Action's within the resulting 'IO'. The
-- @dispatch@ function it is passed will have type @(App () -> IO ())@
--
-- Note that this function calls forkIO internally, so there's no need to do that yourself.
--
-- Here's an example:
--
-- > data Timer = Timer
-- > myTimer :: (App () -> IO ()) -> IO ()
-- > myTimer dispatch = forever $ dispatch (myInt += 1) >> threadDelay 1000000
-- >
-- > myInit :: App ()
-- > myInit = asyncActionProvider myTimer
asyncActionProvider :: (MonadIO m, HasStates base, Typeable m, Typeable base) => ((AppT base m () -> IO ()) -> IO ()) -> ActionT base zoomed m ()
asyncActionProvider provider = runApp $ do
  mQueue <- use asyncQueue
  case mQueue of
    Nothing -> return ()
    Just queue -> liftIO . void . forkIO $ provider (writeChan queue)

-- | This allows synchronous dispatch of actions with result return.
--
-- Similar to 'asyncActionProvider', but the dispatch function blocks until
-- the action is executed in the event loop and returns the result.
--
-- This enables external IO contexts to dispatch actions (like 'dispatchEvent')
-- and receive their monoidal results back.
--
-- Example:
--
-- > data GetNames = GetNames
-- >
-- > myProvider :: (forall a. Typeable a => App a -> IO a) -> IO ()
-- > myProvider dispatch = forever $ do
-- >   names <- dispatch (dispatchEvent GetNames)  -- blocks until result ready
-- >   print names
-- >   threadDelay 1000000
-- >
-- > myInit :: App ()
-- > myInit = syncActionProvider myProvider
syncActionProvider ::
  (HasStates base, MonadIO m, Typeable m, Typeable base) =>
  ((forall a. (Typeable a) => AppT base m a -> IO a) -> IO ()) ->
  ActionT base zoomed m ()
syncActionProvider provider = runApp $ do
  mSyncQueue <- use syncQueue
  mAsyncQueue <- use asyncQueue
  case (mSyncQueue, mAsyncQueue) of
    (Just syncChan, Just asyncChan) ->
      liftIO . void . forkIO $ provider (dispatchSync syncChan asyncChan)
    _ -> error "Queues not initialized. This is a bug in eve."
  where
    dispatchSync syncChan asyncChan action = do
      resultVar <- newEmptyMVar
      writeChan syncChan (SyncAction action resultVar)
      -- Wake up the event loop to process sync actions
      writeChan asyncChan (processSyncActions syncChan)
      takeMVar resultVar

    processSyncActions syncChan = do
      -- Process one sync action
      SyncAction act resultVar <- liftIO $ readChan syncChan
      result <- act
      liftIO $ putMVar resultVar result
